// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mahjong.proto

#ifndef PROTOBUF_mahjong_2eproto__INCLUDED
#define PROTOBUF_mahjong_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mahjong_2eproto();
void protobuf_AssignDesc_mahjong_2eproto();
void protobuf_ShutdownFile_mahjong_2eproto();

class Hand;
class Hand_Pon;
class Hand_Kan;
class Player;
class Field;
class ScoreCalculationResponse;

enum TileType {
  UNKNOWN = 0,
  SEQUENTIAL = 1,
  WANZU = 16,
  WANZU_1 = 256,
  WANZU_2 = 257,
  WANZU_3 = 258,
  WANZU_4 = 259,
  WANZU_5 = 260,
  WANZU_6 = 261,
  WANZU_7 = 262,
  WANZU_8 = 263,
  WANZU_9 = 264,
  SOUZU = 17,
  SOUZU_1 = 272,
  SOUZU_2 = 273,
  SOUZU_3 = 274,
  SOUZU_4 = 275,
  SOUZU_5 = 276,
  SOUZU_6 = 277,
  SOUZU_7 = 278,
  SOUZU_8 = 279,
  SOUZU_9 = 280,
  PINZU = 18,
  PINZU_1 = 288,
  PINZU_2 = 289,
  PINZU_3 = 290,
  PINZU_4 = 291,
  PINZU_5 = 292,
  PINZU_6 = 293,
  PINZU_7 = 294,
  PINZU_8 = 295,
  PINZU_9 = 296,
  UNSEQUENTIAL = 2,
  WIND = 32,
  WIND_TON = 512,
  WIND_NAN = 513,
  WIND_SHA = 514,
  WIND_PE = 515,
  YAKU = 33,
  YAKU_HAKU = 528,
  YAKU_HATSU = 529,
  YAKU_CHUN = 530
};
bool TileType_IsValid(int value);
const TileType TileType_MIN = UNKNOWN;
const TileType TileType_MAX = YAKU_CHUN;
const int TileType_ARRAYSIZE = TileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TileType_descriptor();
inline const ::std::string& TileType_Name(TileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TileType_descriptor(), value);
}
inline bool TileType_Parse(
    const ::std::string& name, TileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TileType>(
    TileType_descriptor(), name, value);
}
// ===================================================================

class Hand_Pon : public ::google::protobuf::Message {
 public:
  Hand_Pon();
  virtual ~Hand_Pon();

  Hand_Pon(const Hand_Pon& from);

  inline Hand_Pon& operator=(const Hand_Pon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hand_Pon& default_instance();

  void Swap(Hand_Pon* other);

  // implements Message ----------------------------------------------

  Hand_Pon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hand_Pon& from);
  void MergeFrom(const Hand_Pon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TileType tile = 1;
  inline bool has_tile() const;
  inline void clear_tile();
  static const int kTileFieldNumber = 1;
  inline ::TileType tile() const;
  inline void set_tile(::TileType value);

  // optional bool is_closed = 2;
  inline bool has_is_closed() const;
  inline void clear_is_closed();
  static const int kIsClosedFieldNumber = 2;
  inline bool is_closed() const;
  inline void set_is_closed(bool value);

  // @@protoc_insertion_point(class_scope:Hand.Pon)
 private:
  inline void set_has_tile();
  inline void clear_has_tile();
  inline void set_has_is_closed();
  inline void clear_has_is_closed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int tile_;
  bool is_closed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mahjong_2eproto();
  friend void protobuf_AssignDesc_mahjong_2eproto();
  friend void protobuf_ShutdownFile_mahjong_2eproto();

  void InitAsDefaultInstance();
  static Hand_Pon* default_instance_;
};
// -------------------------------------------------------------------

class Hand_Kan : public ::google::protobuf::Message {
 public:
  Hand_Kan();
  virtual ~Hand_Kan();

  Hand_Kan(const Hand_Kan& from);

  inline Hand_Kan& operator=(const Hand_Kan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hand_Kan& default_instance();

  void Swap(Hand_Kan* other);

  // implements Message ----------------------------------------------

  Hand_Kan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hand_Kan& from);
  void MergeFrom(const Hand_Kan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TileType tile = 1;
  inline bool has_tile() const;
  inline void clear_tile();
  static const int kTileFieldNumber = 1;
  inline ::TileType tile() const;
  inline void set_tile(::TileType value);

  // optional bool is_closed = 2;
  inline bool has_is_closed() const;
  inline void clear_is_closed();
  static const int kIsClosedFieldNumber = 2;
  inline bool is_closed() const;
  inline void set_is_closed(bool value);

  // @@protoc_insertion_point(class_scope:Hand.Kan)
 private:
  inline void set_has_tile();
  inline void clear_has_tile();
  inline void set_has_is_closed();
  inline void clear_has_is_closed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int tile_;
  bool is_closed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mahjong_2eproto();
  friend void protobuf_AssignDesc_mahjong_2eproto();
  friend void protobuf_ShutdownFile_mahjong_2eproto();

  void InitAsDefaultInstance();
  static Hand_Kan* default_instance_;
};
// -------------------------------------------------------------------

class Hand : public ::google::protobuf::Message {
 public:
  Hand();
  virtual ~Hand();

  Hand(const Hand& from);

  inline Hand& operator=(const Hand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hand& default_instance();

  void Swap(Hand* other);

  // implements Message ----------------------------------------------

  Hand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hand& from);
  void MergeFrom(const Hand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Hand_Pon Pon;
  typedef Hand_Kan Kan;

  // accessors -------------------------------------------------------

  // repeated .TileType closed_tiles = 1;
  inline int closed_tiles_size() const;
  inline void clear_closed_tiles();
  static const int kClosedTilesFieldNumber = 1;
  inline ::TileType closed_tiles(int index) const;
  inline void set_closed_tiles(int index, ::TileType value);
  inline void add_closed_tiles(::TileType value);
  inline const ::google::protobuf::RepeatedField<int>& closed_tiles() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_closed_tiles();

  // repeated .Hand.Pon ponned_tiles = 2;
  inline int ponned_tiles_size() const;
  inline void clear_ponned_tiles();
  static const int kPonnedTilesFieldNumber = 2;
  inline const ::Hand_Pon& ponned_tiles(int index) const;
  inline ::Hand_Pon* mutable_ponned_tiles(int index);
  inline ::Hand_Pon* add_ponned_tiles();
  inline const ::google::protobuf::RepeatedPtrField< ::Hand_Pon >&
      ponned_tiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Hand_Pon >*
      mutable_ponned_tiles();

  // repeated .Hand.Kan Kanned_tiles = 3;
  inline int kanned_tiles_size() const;
  inline void clear_kanned_tiles();
  static const int kKannedTilesFieldNumber = 3;
  inline const ::Hand_Kan& kanned_tiles(int index) const;
  inline ::Hand_Kan* mutable_kanned_tiles(int index);
  inline ::Hand_Kan* add_kanned_tiles();
  inline const ::google::protobuf::RepeatedPtrField< ::Hand_Kan >&
      kanned_tiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Hand_Kan >*
      mutable_kanned_tiles();

  // optional bool is_tsumo = 4;
  inline bool has_is_tsumo() const;
  inline void clear_is_tsumo();
  static const int kIsTsumoFieldNumber = 4;
  inline bool is_tsumo() const;
  inline void set_is_tsumo(bool value);

  // optional bool is_reached = 5;
  inline bool has_is_reached() const;
  inline void clear_is_reached();
  static const int kIsReachedFieldNumber = 5;
  inline bool is_reached() const;
  inline void set_is_reached(bool value);

  // optional .TileType agari_tile = 6;
  inline bool has_agari_tile() const;
  inline void clear_agari_tile();
  static const int kAgariTileFieldNumber = 6;
  inline ::TileType agari_tile() const;
  inline void set_agari_tile(::TileType value);

  // @@protoc_insertion_point(class_scope:Hand)
 private:
  inline void set_has_is_tsumo();
  inline void clear_has_is_tsumo();
  inline void set_has_is_reached();
  inline void clear_has_is_reached();
  inline void set_has_agari_tile();
  inline void clear_has_agari_tile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> closed_tiles_;
  ::google::protobuf::RepeatedPtrField< ::Hand_Pon > ponned_tiles_;
  ::google::protobuf::RepeatedPtrField< ::Hand_Kan > kanned_tiles_;
  bool is_tsumo_;
  bool is_reached_;
  int agari_tile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mahjong_2eproto();
  friend void protobuf_AssignDesc_mahjong_2eproto();
  friend void protobuf_ShutdownFile_mahjong_2eproto();

  void InitAsDefaultInstance();
  static Hand* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TileType my_wind = 1;
  inline bool has_my_wind() const;
  inline void clear_my_wind();
  static const int kMyWindFieldNumber = 1;
  inline ::TileType my_wind() const;
  inline void set_my_wind(::TileType value);

  // optional .Hand my_hand = 2;
  inline bool has_my_hand() const;
  inline void clear_my_hand();
  static const int kMyHandFieldNumber = 2;
  inline const ::Hand& my_hand() const;
  inline ::Hand* mutable_my_hand();
  inline ::Hand* release_my_hand();
  inline void set_allocated_my_hand(::Hand* my_hand);

  // @@protoc_insertion_point(class_scope:Player)
 private:
  inline void set_has_my_wind();
  inline void clear_has_my_wind();
  inline void set_has_my_hand();
  inline void clear_has_my_hand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Hand* my_hand_;
  int my_wind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mahjong_2eproto();
  friend void protobuf_AssignDesc_mahjong_2eproto();
  friend void protobuf_ShutdownFile_mahjong_2eproto();

  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TileType wind = 1;
  inline bool has_wind() const;
  inline void clear_wind();
  static const int kWindFieldNumber = 1;
  inline ::TileType wind() const;
  inline void set_wind(::TileType value);

  // repeated .TileType doras = 2;
  inline int doras_size() const;
  inline void clear_doras();
  static const int kDorasFieldNumber = 2;
  inline ::TileType doras(int index) const;
  inline void set_doras(int index, ::TileType value);
  inline void add_doras(::TileType value);
  inline const ::google::protobuf::RepeatedField<int>& doras() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_doras();

  // optional int32 honba = 3;
  inline bool has_honba() const;
  inline void clear_honba();
  static const int kHonbaFieldNumber = 3;
  inline ::google::protobuf::int32 honba() const;
  inline void set_honba(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Field)
 private:
  inline void set_has_wind();
  inline void clear_has_wind();
  inline void set_has_honba();
  inline void clear_has_honba();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> doras_;
  int wind_;
  ::google::protobuf::int32 honba_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mahjong_2eproto();
  friend void protobuf_AssignDesc_mahjong_2eproto();
  friend void protobuf_ShutdownFile_mahjong_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class ScoreCalculationResponse : public ::google::protobuf::Message {
 public:
  ScoreCalculationResponse();
  virtual ~ScoreCalculationResponse();

  ScoreCalculationResponse(const ScoreCalculationResponse& from);

  inline ScoreCalculationResponse& operator=(const ScoreCalculationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreCalculationResponse& default_instance();

  void Swap(ScoreCalculationResponse* other);

  // implements Message ----------------------------------------------

  ScoreCalculationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreCalculationResponse& from);
  void MergeFrom(const ScoreCalculationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 fu = 1;
  inline bool has_fu() const;
  inline void clear_fu();
  static const int kFuFieldNumber = 1;
  inline ::google::protobuf::int32 fu() const;
  inline void set_fu(::google::protobuf::int32 value);

  // optional int32 fan = 2;
  inline bool has_fan() const;
  inline void clear_fan();
  static const int kFanFieldNumber = 2;
  inline ::google::protobuf::int32 fan() const;
  inline void set_fan(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ScoreCalculationResponse)
 private:
  inline void set_has_fu();
  inline void clear_has_fu();
  inline void set_has_fan();
  inline void clear_has_fan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 fu_;
  ::google::protobuf::int32 fan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mahjong_2eproto();
  friend void protobuf_AssignDesc_mahjong_2eproto();
  friend void protobuf_ShutdownFile_mahjong_2eproto();

  void InitAsDefaultInstance();
  static ScoreCalculationResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Hand_Pon

// optional .TileType tile = 1;
inline bool Hand_Pon::has_tile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hand_Pon::set_has_tile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hand_Pon::clear_has_tile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hand_Pon::clear_tile() {
  tile_ = 0;
  clear_has_tile();
}
inline ::TileType Hand_Pon::tile() const {
  return static_cast< ::TileType >(tile_);
}
inline void Hand_Pon::set_tile(::TileType value) {
  assert(::TileType_IsValid(value));
  set_has_tile();
  tile_ = value;
}

// optional bool is_closed = 2;
inline bool Hand_Pon::has_is_closed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hand_Pon::set_has_is_closed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hand_Pon::clear_has_is_closed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hand_Pon::clear_is_closed() {
  is_closed_ = false;
  clear_has_is_closed();
}
inline bool Hand_Pon::is_closed() const {
  return is_closed_;
}
inline void Hand_Pon::set_is_closed(bool value) {
  set_has_is_closed();
  is_closed_ = value;
}

// -------------------------------------------------------------------

// Hand_Kan

// optional .TileType tile = 1;
inline bool Hand_Kan::has_tile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hand_Kan::set_has_tile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hand_Kan::clear_has_tile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hand_Kan::clear_tile() {
  tile_ = 0;
  clear_has_tile();
}
inline ::TileType Hand_Kan::tile() const {
  return static_cast< ::TileType >(tile_);
}
inline void Hand_Kan::set_tile(::TileType value) {
  assert(::TileType_IsValid(value));
  set_has_tile();
  tile_ = value;
}

// optional bool is_closed = 2;
inline bool Hand_Kan::has_is_closed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hand_Kan::set_has_is_closed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hand_Kan::clear_has_is_closed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hand_Kan::clear_is_closed() {
  is_closed_ = false;
  clear_has_is_closed();
}
inline bool Hand_Kan::is_closed() const {
  return is_closed_;
}
inline void Hand_Kan::set_is_closed(bool value) {
  set_has_is_closed();
  is_closed_ = value;
}

// -------------------------------------------------------------------

// Hand

// repeated .TileType closed_tiles = 1;
inline int Hand::closed_tiles_size() const {
  return closed_tiles_.size();
}
inline void Hand::clear_closed_tiles() {
  closed_tiles_.Clear();
}
inline ::TileType Hand::closed_tiles(int index) const {
  return static_cast< ::TileType >(closed_tiles_.Get(index));
}
inline void Hand::set_closed_tiles(int index, ::TileType value) {
  assert(::TileType_IsValid(value));
  closed_tiles_.Set(index, value);
}
inline void Hand::add_closed_tiles(::TileType value) {
  assert(::TileType_IsValid(value));
  closed_tiles_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Hand::closed_tiles() const {
  return closed_tiles_;
}
inline ::google::protobuf::RepeatedField<int>*
Hand::mutable_closed_tiles() {
  return &closed_tiles_;
}

// repeated .Hand.Pon ponned_tiles = 2;
inline int Hand::ponned_tiles_size() const {
  return ponned_tiles_.size();
}
inline void Hand::clear_ponned_tiles() {
  ponned_tiles_.Clear();
}
inline const ::Hand_Pon& Hand::ponned_tiles(int index) const {
  return ponned_tiles_.Get(index);
}
inline ::Hand_Pon* Hand::mutable_ponned_tiles(int index) {
  return ponned_tiles_.Mutable(index);
}
inline ::Hand_Pon* Hand::add_ponned_tiles() {
  return ponned_tiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Hand_Pon >&
Hand::ponned_tiles() const {
  return ponned_tiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Hand_Pon >*
Hand::mutable_ponned_tiles() {
  return &ponned_tiles_;
}

// repeated .Hand.Kan Kanned_tiles = 3;
inline int Hand::kanned_tiles_size() const {
  return kanned_tiles_.size();
}
inline void Hand::clear_kanned_tiles() {
  kanned_tiles_.Clear();
}
inline const ::Hand_Kan& Hand::kanned_tiles(int index) const {
  return kanned_tiles_.Get(index);
}
inline ::Hand_Kan* Hand::mutable_kanned_tiles(int index) {
  return kanned_tiles_.Mutable(index);
}
inline ::Hand_Kan* Hand::add_kanned_tiles() {
  return kanned_tiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Hand_Kan >&
Hand::kanned_tiles() const {
  return kanned_tiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Hand_Kan >*
Hand::mutable_kanned_tiles() {
  return &kanned_tiles_;
}

// optional bool is_tsumo = 4;
inline bool Hand::has_is_tsumo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hand::set_has_is_tsumo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hand::clear_has_is_tsumo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hand::clear_is_tsumo() {
  is_tsumo_ = false;
  clear_has_is_tsumo();
}
inline bool Hand::is_tsumo() const {
  return is_tsumo_;
}
inline void Hand::set_is_tsumo(bool value) {
  set_has_is_tsumo();
  is_tsumo_ = value;
}

// optional bool is_reached = 5;
inline bool Hand::has_is_reached() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hand::set_has_is_reached() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hand::clear_has_is_reached() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hand::clear_is_reached() {
  is_reached_ = false;
  clear_has_is_reached();
}
inline bool Hand::is_reached() const {
  return is_reached_;
}
inline void Hand::set_is_reached(bool value) {
  set_has_is_reached();
  is_reached_ = value;
}

// optional .TileType agari_tile = 6;
inline bool Hand::has_agari_tile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hand::set_has_agari_tile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hand::clear_has_agari_tile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hand::clear_agari_tile() {
  agari_tile_ = 0;
  clear_has_agari_tile();
}
inline ::TileType Hand::agari_tile() const {
  return static_cast< ::TileType >(agari_tile_);
}
inline void Hand::set_agari_tile(::TileType value) {
  assert(::TileType_IsValid(value));
  set_has_agari_tile();
  agari_tile_ = value;
}

// -------------------------------------------------------------------

// Player

// optional .TileType my_wind = 1;
inline bool Player::has_my_wind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_my_wind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_my_wind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_my_wind() {
  my_wind_ = 0;
  clear_has_my_wind();
}
inline ::TileType Player::my_wind() const {
  return static_cast< ::TileType >(my_wind_);
}
inline void Player::set_my_wind(::TileType value) {
  assert(::TileType_IsValid(value));
  set_has_my_wind();
  my_wind_ = value;
}

// optional .Hand my_hand = 2;
inline bool Player::has_my_hand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_my_hand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_my_hand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_my_hand() {
  if (my_hand_ != NULL) my_hand_->::Hand::Clear();
  clear_has_my_hand();
}
inline const ::Hand& Player::my_hand() const {
  return my_hand_ != NULL ? *my_hand_ : *default_instance_->my_hand_;
}
inline ::Hand* Player::mutable_my_hand() {
  set_has_my_hand();
  if (my_hand_ == NULL) my_hand_ = new ::Hand;
  return my_hand_;
}
inline ::Hand* Player::release_my_hand() {
  clear_has_my_hand();
  ::Hand* temp = my_hand_;
  my_hand_ = NULL;
  return temp;
}
inline void Player::set_allocated_my_hand(::Hand* my_hand) {
  delete my_hand_;
  my_hand_ = my_hand;
  if (my_hand) {
    set_has_my_hand();
  } else {
    clear_has_my_hand();
  }
}

// -------------------------------------------------------------------

// Field

// optional .TileType wind = 1;
inline bool Field::has_wind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_wind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_wind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_wind() {
  wind_ = 0;
  clear_has_wind();
}
inline ::TileType Field::wind() const {
  return static_cast< ::TileType >(wind_);
}
inline void Field::set_wind(::TileType value) {
  assert(::TileType_IsValid(value));
  set_has_wind();
  wind_ = value;
}

// repeated .TileType doras = 2;
inline int Field::doras_size() const {
  return doras_.size();
}
inline void Field::clear_doras() {
  doras_.Clear();
}
inline ::TileType Field::doras(int index) const {
  return static_cast< ::TileType >(doras_.Get(index));
}
inline void Field::set_doras(int index, ::TileType value) {
  assert(::TileType_IsValid(value));
  doras_.Set(index, value);
}
inline void Field::add_doras(::TileType value) {
  assert(::TileType_IsValid(value));
  doras_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Field::doras() const {
  return doras_;
}
inline ::google::protobuf::RepeatedField<int>*
Field::mutable_doras() {
  return &doras_;
}

// optional int32 honba = 3;
inline bool Field::has_honba() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Field::set_has_honba() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Field::clear_has_honba() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Field::clear_honba() {
  honba_ = 0;
  clear_has_honba();
}
inline ::google::protobuf::int32 Field::honba() const {
  return honba_;
}
inline void Field::set_honba(::google::protobuf::int32 value) {
  set_has_honba();
  honba_ = value;
}

// -------------------------------------------------------------------

// ScoreCalculationResponse

// optional int32 fu = 1;
inline bool ScoreCalculationResponse::has_fu() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreCalculationResponse::set_has_fu() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreCalculationResponse::clear_has_fu() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreCalculationResponse::clear_fu() {
  fu_ = 0;
  clear_has_fu();
}
inline ::google::protobuf::int32 ScoreCalculationResponse::fu() const {
  return fu_;
}
inline void ScoreCalculationResponse::set_fu(::google::protobuf::int32 value) {
  set_has_fu();
  fu_ = value;
}

// optional int32 fan = 2;
inline bool ScoreCalculationResponse::has_fan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreCalculationResponse::set_has_fan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreCalculationResponse::clear_has_fan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreCalculationResponse::clear_fan() {
  fan_ = 0;
  clear_has_fan();
}
inline ::google::protobuf::int32 ScoreCalculationResponse::fan() const {
  return fan_;
}
inline void ScoreCalculationResponse::set_fan(::google::protobuf::int32 value) {
  set_has_fan();
  fan_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TileType>() {
  return ::TileType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mahjong_2eproto__INCLUDED
